# Reference

## [ActivityExt](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ActivityExt.kt)

Defines extension functions for setting the state of an Activity.

#### Toggle the visibility of the status bar.

```kotlin
fun FragmentActivity.hideStatusBar()
fun FragmentActivity.showStatusBar()
fun FragmentActivity.showStatusBar(flag:Boolean)
```

#### Toggle the visibility of the action bar.

```kotlin
fun AppCompatActivity.hideActionBar()
fun AppCompatActivity.showActionBar()
fun AppCompatActivity.showActionBar(flag:Boolean)
```

#### Set the orientation of the Activity.

```kotlin
fun FragmentActivity.setOrientation(orientation:ActivityOrientation)
```

#### Set the preset state

```kotlin
val normalOptions = ActivityOptions.actionAndStatusBar(showActionBar=true, showStatusBar=true, orientation=ActivityOrientation.AUTO)
val editingOptions = ActivityOptions.actionAndStatusBar(showActionBar=false, showStatusBar=false, orientation=ActivityOrientation.LANDSCAPE)

fun onEditingModeChanged(editing:Boolean) {
  val options = if (editing) editingOptions else normalOptions
  options.apply(this)
}
```

Additionally, by using [android-binding's activityOptionsBinding](https://github.com/toyota-m2k/android-binding/blob/main/libBinder/src/main/java/io/github/toyota32k/binder/ActivityBinding.kt), you can bind these states reactively to a view model (Flow<ActivityOptions>) to update them.

## [ApplicationViewModelStoreOwner](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ApplicationViewModelStoreOwner.kt)

An implementation class of `ViewModelStore` that ensures the survival of ViewModel at the application scope. It is used to create a ViewModel that does not depend on the lifecycle of activities, etc. Naturally, using it carelessly can lead to resource leaks, so caution is necessary.

## [Callback](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/Callback.kt)

A handler container that can hold only one callback function. When the lifecycle owner is destroyed (when `Lifecycle.State.DESTROYED`), the handler registration is automatically removed. To register multiple handlers, use the [Listeners](#listeners) class.

## [Chronos](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/Chronos.kt)

A debugging time measurement class. It can measure the time from the function call to its return and record lap times before and after individual function calls. The measurement results are output to [UtLog](#utlog). If you just want to measure the time for one block, using `UtLog#chronos()` is convenient.

#### Example usage

```Kotlin
val logger = UtLog("Sample")
fun takePicture(): Bitmap? {
    logger.chronos {
        return try {
            imageCapture.take()
        } catch (e: Throwable) {
            TcLib.logger.error(e)
            null
        }
    }
}
```

## [ConstantLiveData](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ConstantLiveData.kt)

A `LiveData` class whose value does not change. It can be used to handle APIs that require `LiveData` (such as [android-binding](https://github.com/toyota-m2k/android-binding)) in a consistent manner.

## [ConvertLiveData](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ConvertLiveData.kt)

A `LiveData` type that supports bidirectional type conversion, such as string-to-numeric conversions. For one-way conversions, like converting a `bool` value to `View.visibility` to toggle visibility, filter operators like `map` are sufficient. However, it is used when binding the `text` property of `EditText` (String type) to a numeric type in a bidirectional conversion.

## [DisposableObserver](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/DisposableObserver.kt)

A class that handles the observe/removeObserver of `LiveData` as an `IDisposable` interface. It is generated by the extension functions `disposableObserve()` or `disposableObserveForever()` of `LiveData`. Normally, `observe()` of `LiveData` requires creating an `Observer` class and holding both instances of `LiveData` and `Observer` to call `removeObserver`, but with `DisposableObserver`, you can unregister the observer by calling `dispose()`. `DisposableObserver` generated by `disposableObserve()` works according to the lifecycle of the `LifecycleOwner` (such as `Activity`), so in the following example, it is not necessary to call `disposable.dispose()` in `onDestroy`. However, a `DisposableObserver` created by `disposableObserveForever()` must be explicitly released by calling `dispose()`.

#### Example usage
```kotlin
private lateinit var liveData:LiveData<Boolean>
private var disposable:IDisposable? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    disposable = liveData.disposableObserve(this/*LifecycleOwner*/) {
        if (it) {
            // To remove the observer, just call dispose
            disposable?.dispose()
            disposable = null
        }
    }
}
```

## [DisposableFlowObserver](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/DisposableFlowObserver.kt)

The Flow version of [DisposableObserver](#disposableobserver). It is generated by the extension functions `disposeObserve()` or `disposableObserveForever()` of `Flow`. The `DisposableFlowObserver` created by `disposableObserve()` operates within the lifecycle of the `LifecycleOwner` (such as an Activity) or within a `CoroutineScope`, so in the following example, it is not necessary to call `disposable.dispose()` in `onDestroy`. However, a `DisposableFlowObserver` created by `disposableObserveForever()` must be explicitly released by calling `dispose()`.

#### Example usage

```kotlin
private lateinit var flow:Flow<Boolean>
private var disposable:IDisposable? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    disposable = flow.disposableObserve(this/*LifecycleOwner*/) {
        if (it) {
            // To remove the observer, just call dispose
            disposable?.dispose()
            disposable = null
        }
    }
}
```

## [Disposer](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/Disposer.kt)

A collection of `IDisposable`. By creating a `Disposer` instance and registering `IDisposable` (using `register` or the `+` operator), you can dispose of them all at once with the `Disposer#dispose()` method. By using the derived class [LifecycleDisposer](#lifecycledisposer), you can automatically call `dispose()` according to the lifecycle of the `LifecycleOwner` (such as an Activity).

#### Example usage

```kotlin
private lateinit var dataA:LiveData<Boolean>
private lateinit var dataB:LiveData<Int>
private lateinit var dataC:LiveData<String>

private val disposer = Disposer()

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    disposer
        .register(dataA.disposableObserveForever { updateA(it) })
        .register(dataB.disposableObserveForever { updateB(it) })
        .register(dataC.disposableObserveForever { updateC(it) })
}

override fun onDestroy() {
    disposer.dispose()
}
```

## [FlowableEvent](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/FlowableEvent.kt)

A synchronization object for waiting for events to occur. This class is equivalent to .NET's `ManualResetEvent/AutoResetEvent`. It uses `Flow` internally, and when `waitOne()` is called, it suspends until `set()` is called externally.

#### Example usage

```kotlin
suspend fun example() {
    val event = FlowableEvent()
    var result = false
    coroutineScope(Dispatchers.IO).launch {
        // do something
        result = true
        event.set()
    }
    event.waitOne() // Waits until event.set() is called
    assert(result == true)
}
```

## [FlowExt](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/FlowExt.kt)

Extension functions for `Flow`. Instead of writing `viewModel.someBooleanProperty.value = !viewModel.someBooleanProperty.value`, you can write `viewModel.someBooleanProperty.toggle()`. It's such a trivial function that I almost forgot I made it.

```kotlin
fun MutableStateFlow<Boolean>.toggle()
```

## [GenericCloseable](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/GenericCloseable.kt)

A class that wraps processes requiring cleanup in the `Closeable` interface. Using `use()` instead of `try/finally` prevents cleanup leaks.

Extension function for converting `IDisposable` to `Closeable`:
```kotlin
fun IDisposable.asCloseable(): Closeable
```

## [GenericDisposable](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/GenericDisposable.kt)

The `IDisposable` version of `GenericCloseable`. It is a class that wraps processes requiring cleanup in the `IDisposable` interface. You can register it with [Disposer](#disposer) or [LifecycleDisposer](#lifecycledisposer) to manage cleanup collectively.

#### Example usage

```kotlin
val disposable = GenericDisposable.create {
    // Set onFocusChangedListener
    val edit = findViewById(R.id.edit_text)
    edit?.setOnFocusChangeListener { _, focus ->
        viewModel.focus = focus
    }
    { edit.onFocusChangeListener = null }
}

// If no longer needed, call dispose() to remove the listener
disposable.dispose()
```

Extension function for converting `Closeable` to `IDisposable`:
```kotlin
fun Closeable.asDisposable(): IDisposable
```

## [IAwaiter](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/IAwaiter.kt)

An interface that abstracts cancellable waiting tasks.

It is used as the return type of cancellable functions. Compared to directly returning a `Job` or `CoroutineScope`, it provides the advantage of flexibility in internal implementation.

## [IDisposable](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/IDisposable.kt)

An interface familiar to .NET immigrants. In Java, `Closeable` and `AutoCloseable` are common, but `dispose()` feels more like Rx than `close()` (personal opinion), so it was defined for self-made applications. With the extension functions `IDisposable#asCloseable()` and `Closeable#asDisposable()`, it is possible to convert between the `Closeable` interface and `IDisposable`.

## [LifecycleDisposer](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/LifecycleDisposer.kt)

A derived class of [Disposer](#disposer) that automatically calls `dispose()` when the lifecycle owner is destroyed.

## [LifecycleOwnerHolder](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/LifecycleOwnerHolder.kt)

A class that safely holds a reference to the lifecycle owner. Objects like `Activity` that are destroyed and recreated according to the lifecycle should not be held as static variables, application scope variables, or fields of `ViewModel` as it would result in resource leaks. However, if it is absolutely necessary, you can use this class. It releases the reference when the lifecycle owner is destroyed, avoiding leaks.

## [LifecycleReference](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/LifecycleReference.kt)

A class that holds an object that can only be referenced during the lifecycle of the owner. It works like a `WeakReference`. When the lifecycle owner is destroyed, the referenced object (`LifecycleReference#value`) becomes `null`.

#### Example usage

```kotlin
class ViewModel {
    var viewRef: LifecycleReference<View>? = null
    fun doSomething {
        val view = viewRef?.value ?: return
        // view is set in MainActivity's onCreate and is valid until onDestroy. After onDestroy, it returns null.
    }
}
class MainActivity {
    lateinit var viewModel:ViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        viewModel.viewRef = LifecycleReference(findViewById(R.id.view))
    }
}
```

## [Listeners](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/Listeners.kt)

A handler container that can hold multiple callback functions. When the lifecycle owner is destroyed (when `Lifecycle.State.DESTROYED`), the handler registration is automatically removed. If you want to register only one handler, consider using the [Callback](#callback) class.

## [ListSorter](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ListSorter.kt)

Deprecated. Please use [UtSorter](#utsorter) instead.

## [LiveDataExt](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/LiveDataExt.kt)

Extension functions that add Rx-like operators to `LiveData`.

- `fun <T, R> LiveData<T>.mapEx(fn: (T?) -> R): LiveData<R>`<br>
  Use this when the initial value needs to be reflected, as `LiveData.map` does not reflect the initial value.
- `fun <T> LiveData<T>.filter(predicate: (T?) -> Boolean): LiveData<T>`
- `fun <T> LiveData<T>.notNull(): LiveData<T>`
- `fun <T1, T2, R> combineLatest(src1: LiveData<T1>, src2: LiveData<T2>, fn: (T1?, T2?) -> R?): LiveData<R>`
- `fun or(vararg args: LiveData<Boolean>): LiveData<Boolean>`
- `fun and(vararg args: LiveData<Boolean>): LiveData<Boolean>`
- `fun LiveData<Boolean>.not(): LiveData<Boolean>`

## [Logger](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/Logger.kt)

A basic implementation of a low-level logging API (`IUtVaLogger`) used by `UtLog`. By default, it outputs logs to LogCat. If additional actions such as saving to a file are needed, set an object that implements `IUtExternalLogger` to `UtLoggerInstance.externalLogger`.

## [MuSize](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/MuSize.kt)

A mutable `Size` class. After instance creation, you can change the `width` and `height`. It is also possible to convert between `Size` and `SizeF`.

## [NamedMutex](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/NamedMutex.kt)

A named mutex class. This allows creating and referencing a mutex class globally using a name as the key.

## [ObservableFlow](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ObservableFlow.kt)

A class that adds `observe` methods (similar to `LiveData`) to `Flow`. Like `LiveData`, it registers observers with `observe()` and removes them with `removeObserver()`. However, unlike `LiveData.observe()`, it monitors within the provided `CoroutineContext` rather than the lifecycle of the `LifecycleOwner`.

Usually, using the extension function `Flow#disposableObserve()` is convenient, but `ObservableFlow` differs in that it allows forced removal of observers from the observed side. That is, while `disposableObserve()` expects the observer to take responsibility for disposing of it, `ObservableFlow` is used when you want to ensure observers are removed when the observed processing is completed, such as when observed adhoc from external sources.

## [PackageUtil](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/PackageUtil.kt)

A utility for handling packages. Currently, it only implements the functionality to get the version number from a package.

## [ProgressWorkerProcessor](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ProgressWorkerProcessor.kt)

Since Android 15, network connections are cut off a few seconds after an app goes into the background (when switched to another app). Therefore, if the user switches to another app while uploading or downloading a file, the process fails. To avoid this issue, you need to use [WorkManager](https://developer.android.com/reference/androidx/work/WorkManager). `ProgressWorkerProcessor` is a boilerplate class that adds the following to background processing with WorkManager:
- Progress notification: Uses the `progress(current, total)` callback.
- Cancel background processing: Uses [IAwaiter](#iawaiter).

To use `ProgressWorkerProcessor`, first create a class derived from `ProgressWorker` and override `doWork()`. Implement the background processing in `doWork()` and notify the caller of progress by calling `progressManager#progress()` as needed.

To start the `Worker`, use `ProgressWorkerProcessor#process()`. Since you cannot pass regular arguments to the `Worker` from the caller, use [androidx.work.Data](https://developer.android.com/reference/androidx/work/Data) for parameter passing. The following is an example of downloading using WorkManager, where the `download()` method is prepared in the `Downloader` object class to hide the complicated processing related to the call to `ProgressWorkerProcessor#process()`, including parameter passing.

#### Example Usage
```kotlin
object Downloader {
    const val KEY_URL = "url"
    const val KEY_FILE_PATH = "path"

    val processor = ProgressWorkerProcessor()

    /**
     * Implementation class of background processing derived from ProgressWorker
     */
    class DownloadWorker(context: Context, params: WorkerParameters) : ProgressWorker(context, params) {
        private suspend fun downloadUrlToFile(url: String, file: File) {
            var connection: HttpURLConnection? = null
            try {
                connection = (URL(url).openConnection() as HttpURLConnection).apply { connect() }
                if (connection.responseCode != HttpURLConnection.HTTP_OK) {
                    throw Exception("Server returned HTTP ${connection.responseCode} ${connection.responseMessage}")
                }
                val fileLength = connection.contentLength.toLong()
                connection.inputStream.use { inputStream->
                FileOutputStream(file).use { outputStream ->
                    val buffer = ByteArray(4096)
                    var totalBytesRead = 0L
                    var bytesRead: Int
                    while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                        outputStream.write(buffer, 0, bytesRead)
                        totalBytesRead += bytesRead
                        progress(totalBytesRead, fileLength)
                        yield() // Detect cancellation of CoroutineScope
                    }
                }}
            } finally {
                connection?.disconnect()
            }
        }

        /**
         * Background processing
         */
        override suspend fun doWork(): Result {
            return try {
                val url = inputData.getString(KEY_URL) ?: return Result.failure()
                val file = File(inputData.getString(KEY_FILE_PATH) ?: return Result.failure())
                downloadUrlToFile(url, file)
                Result.success()
            } catch (_: CancellationException) {
                // cancelled
                return Result.failure()
            } catch (e: Throwable) {
                // download error
                return Result.failure()
            }
        }
    }

    /**
     * Download file using WorkManager
     * @param context
     * @param url   Target URL
     * @param path  File save path
     * @param progress Callback function for progress reporting
     * @return IAwaiter for waiting/cancellation 
     */
    fun download(context:Context, url:String, path:String, progress:((current:Long, total:Long)->Unit)?):IAwaiter<Boolean> {
        // Request execution of DownloadWorker
        // The parameters used by DownloadWorker are set to androidx.work.Data using workDataOf().
        return processor.process<DownloadWorker>(context,
            workDataOf(
                KEY_URL to url,
                KEY_FILE_PATH to path,
            ), progress)
    }
}
```

## [SharedPreferenceDelegate](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/SharedPreferenceDelegate.kt)

A class that provides an implementation of the `ReadWriteProperty` interface to enable property delegation for reading and writing Android's `SharedPreference`.

#### Example usage

```kotlin
object Settings {
    private lateinit var spd: SharedPreferenceDelegate

    fun initialize(application: Application) {
        if (this::spd.isInitialized) return
        spd = SharedPreferenceDelegate(application)
    }
    
    var userName by spd.pref("")
    var deviceName by spd.pref(Build.MODEL)
    var activated by spd.pref(false)
}
```

## [SingleLiveEvent](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/SingleLiveEvent.kt)

A reconstruction based on the `SingleLiveEvent` introduced in [Using LiveData for events](https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150). However, it has very few use cases. Usually, the Listener / Callback class or the Command classes of [android-binding](https://github.com/toyota-m2k/android-binding) are used instead.

## [StateFlowConnector](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/StateFlowConnector.kt)

A class that connects the output of a `Flow` to the input of another `MutableStateFlow`. Usually, you refer to a `Flow` directly and manipulate it with Rx operators, but in cases where two independent `ViewModel`s each instantiate separate `MutableStateFlow`, this class is used to connect them and copy changes from one to the other.

In the following example, `ModelB#output` is connected to `ModelA#input`. Although the proper method is to implement `ModelA` to accept `input:StateFlow<Int>` from the constructor or similar, this class is used to connect the inputs and outputs when the models are defined in separate libraries and you do not want to change their structure.

#### Example usage

```kotlin
class ModelA {
    val input = MutableStateFlow<Int>(0)
}
class ModelB {
    val output = MutableStateFlow<Int>(0)
}
val modelA = ModelA()
val modelB = ModelB()

fun foo() {
    modelB.output.connectTo(modelA.input).asCloseable().use {
        for (i in 1..100) {
            modelB.output.value = i
            delay(1000)
        }
    }
}
```

## SuspendableEvent

An event class using Kotlin Channel. (Deprecated) Please use the `Flow`-based [FlowableEvent](#flowableevent).

## [TimeKeeper](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/TimeKeeper.kt)

A class that generalizes periodic processing. It can be used for simple delayed execution or repeated execution, but for example, you can write timer-based processing such as "close the panel if there is no operation for 3 seconds (= touch() is not called)."

#### Example usage
```kotlin
val timeKeeper = TimeKeeper(lifecycleScope, "sample")
var count = 0
// Calls doSomething() 100 times at a pace of once per second.
timeKeeper.start(1000, pause=false, repeat=true) {
    doSomething()
    count++
    if (count == 100)
        timeKeeper.stop()
    }
}
```

## [TimeSpan](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/TimeSpan.kt)

A class that breaks down and formats time given in milliseconds into hours, minutes, and seconds. It has the same name as .NET's `TimeSpan`, but it is entirely different.

## [TintDrawable](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/TintDrawable.kt)

A helper class for programmatically changing the color (tint) of Android icons (Vector Path-based `Drawable`).

## [UtAwaitable](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtAwaitable.kt)

A class that suspends until `complete` is called when `await` is called. Normally, `FlowableEvent` is used, but this class was created for calling from Java rather than Kotlin.


## [UtFitter](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtFitter.kt)

A class for calculating the size when placing child views to fit the parent view area.

It calculates the size according to the given `FitMode`.

| FitMode | Operation |
| ---- | ---- |
| Width | Adjusts the height to match the specified width without changing the aspect ratio |
| Height | Adjusts the width to match the specified height without changing the aspect ratio |
| Inside | Adjusts the width and height to fit within the specified width and height without changing the aspect ratio |
| Fit | Changes to the specified width and height |

## [UtLog](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtLog.kt)

A utility for log output. It automatically adds tags, class names, function names, etc., to the output string.

## [UtMutableStateFlowLiveData](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtMutableStateFlowLiveData.kt)

A conversion class for using `MutableStateFlow` as `MutableLiveData`.

- `fun <T> MutableStateFlow<T>.asMutableLiveData(lifecycleOwner: LifecycleOwner): MutableLiveData<T>`

## [UtObservableCounter](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtObservableCounter.kt)

A reference counter class that can monitor the number of references using `Flow`.

## [UtObservableFlag](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtObservableFlag.kt)

A flag class that can be monitored using `Flow`. By using `trySetIfNot()` and `withFlagIfNot()`, it can be used as a simple boolean flag. Internally, the flag state is maintained as a counter, allowing nested calls.


## [UtPropOwner](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtPropOwner.kt)

A utility to expose `MutableStateFlow` fields as immutable `StateFlow` (or `Flow`) fields.

In `ViewModel`, `MutableStateFlow` is used to implement observable fields, but often these fields are meant to be read-only from the outside (View) and only modified within the `ViewModel`. Such fields should be exposed to the outside as `StateFlow` (or `Flow`).

To achieve this, we have provided a definition that allows "fields to be exposed as `StateFlow` externally while being treated as `MutableStateFlow` internally". Here is how it is used:

1. Derive the class (such as a `ViewModel` derived class) that wants to use this mechanism from `IUtPropOwner`.
2. Implement the property as `val prop: StateFlow<T> = MutableStateFlow<T>()`.
3. When changing the value of the property, set the value to `prop.mutable.value` from within the class.

#### Example usage
```kotlin
class Some : IUtPropOwner {
    // From the outside, someProperty appears as a read-only StateFlow<String>
    public val someProperty: StateFlow<String> = MutableStateFlow("initial")

    fun update(msg: String) {
        // Internally, someProperty.mutable can be used to change the value as MutableStateFlow
        someProperty.mutable.value = "${Date()} $msg"
    }
}
```

Note that `mutable` is an extension property of `Flow` hidden within the `IUtPropOwner` interface. Therefore, from a class inheriting from `IUtPropOwner`, the `mutable` property can be used even on non-Mutable `StateFlow`, but obviously, accessing it will throw an `IllegalCastException`.

## [UtResetableValue](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtResetableValue.kt)

A class that defines a resettable variable that can be used without null checks.

When you use
```kotlin
lateinit var some: SomeClass
```
`some` is a non-null type, so it is convenient as it can be used without null checks. However, once a value is set, it cannot be reverted to an uninitialized state. For example,
```kotlin
class SomeFile {
    lateinit var file: File
    fun open(target: File) {
        file = target
    }
    fun doSomething() {
        file.doSomething()  // No null check needed
    }
    fun close() {
        // Cannot revert the file field to "unset" state
        // file = null
    }
}
```
In such cases, the `file` field would need to be nullable to represent the unset state, and using it would require null checks.
```kotlin
class SomeFile {
    var file: File? = null
    fun open(target: File) {
        file = target
    }
    fun doSomething() {
        file?.doSomething()  // Null check needed
    }
    fun close() {
        // Reverting to initial state
        file = null
    }
}
```
If the validity or invalidity of the value is managed correctly by other means, performing unnecessary null checks every time is not ideal. Therefore, I created a class that can be used like `lateinit` (without null checks) and can also be reset to an uninitialized state.


```kotlin
interface IUtResetableValue<T>
```
Definition of the interface for a resettable `lateinit`-like class.

```kotlin
class UtResetableValue<T>
```
The most basic class. It simply allows setting, getting, and resetting the value.

```kotlin
class UtLazyResetableValue<T>(val fn: () -> T)
```
A class that performs lazy initialization when the value is requested. Pass the value initialization function to the constructor. Even after calling `reset()`, the value will be automatically reinitialized when referenced.

```kotlin
class UtResetableFlowValue<T>(private val flow: MutableStateFlow<T?>)
```
A class that can be treated as equivalent to `UtResetableValue<T>` and can also monitor the value as `Flow<T?>`. When operated as `Flow`, the reset state is represented by `null`, making it `Flow<T?>` (nullable).

```kotlin
class UtNullableResetableValue<T>(
  private val allowKeepNull: Boolean = false, 
  private val lazy: (() -> T?)? = null
)
```
A class that allows `UtLazyResetableValue` to hold `null`. If `allowKeepNull = true`, setting `null` will still result in `hasValue == true`. This deviates from the original purpose of `IUtResetableValue`, which is to hold a value that can be used without null checks and can be reinitialized.

```kotlin
class UtManualIncarnateResetableValue<T>(
  private val onIncarnate: () -> T, 
  private val onReset: ((T) -> Unit)?
)
```
Almost the same as `UtLazyResetableValue`, but once reset, the value will not be automatically reinitialized unless `incarnate()` is called, and will throw an exception (NRE) if referenced.

## [UtSortedList](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtSortedList.kt)

A list class that always maintains a sorted state. It can replace `MutableList`.

## [UtSorter](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/UtSorter.kt)

Encapsulates a `MutableList` and allows adding (inserting) items while maintaining a sorted state. If it is possible to replace the `MutableList` class, `UtSortedList` can be used. However, if a simple replacement is not possible, for example, if you want to use [ObservableList](https://github.com/toyota-m2k/android-binding/blob/main/libBinder/src/main/java/io/github/toyota32k/binder/list/ObservableList.kt) in a sorted state, `UtSorter` can be used to add sorting functionality to the existing `MutableList` derived class.

#### Example usage
```kotlin
val list = mutableListOf<Int>()
val sorter = UtSorter(list, allowDuplication=false, comparator={ a, b -> a - b })
sorter.add(35)
sorter.add(7)
sorter.add(29)
// The list will be sorted in the order 7, 29, 35
```

## [ViewExt](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/ViewExt.kt)

Defines extension functions for manipulating the size, margins, and size calculations (such as dp/px conversion) of views.

#### Extension functions for `Context`
```kotlin
fun Context.activity(): Activity?
fun Context.lifecycleOwner(): LifecycleOwner?
fun Context.viewModelStorageOwner(): ViewModelStoreOwner?
```
These retrieve the `Activity`, `LifecycleOwner`, and `ViewModelStoreOwner` to which the `Context` belongs. If it is the `ApplicationContext`, it returns null.

```kotlin
fun Context.dpToPx(dp: Float): Int
fun Context.pxToDp(px: Float): Int
```
These convert between DP and Pixels.

#### Extension functions for `View`
```kotlin
fun View.activity(): Activity?
fun View.lifecycleOwner(): LifecycleOwner?
fun View.viewModelStorageOwner(): ViewModelStoreOwner?
```
These retrieve the `Activity`, `LifecycleOwner`, and `ViewModelStoreOwner` to which the `View` belongs.

```kotlin
fun View.getLayoutWidth(): Int
fun View.setLayoutWidth(width: Int)
fun View.getLayoutHeight(): Int
fun View.setLayoutHeight(height: Int)
fun View.setLayoutSize(width: Int, height: Int)
```
These get/set the width/height of the `LayoutParams` of the view.

```kotlin
fun View.setMargin(left: Int, top: Int, right: Int, bottom: Int)
```
Sets the margins in the `MarginLayoutParams` of the view.

```kotlin
fun View.measureAndGetSize(): Size
```
Returns the size of the view. After calling `View#measure()`, it retrieves `measuredWidth` and `measuredHeight`.

#### Extension functions for `ListView`
```kotlin
fun ListView.calcContentHeight(): Int
fun ListView.calcFixedContentHeight(): Int
```
Calculates the height of the content (total height of each item) of the `ListView`. The first is for variable item sizes, and the second is for fixed item sizes.

## [StyledAttrRetriever](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/StyledAttrRetriever.kt)

A wrapper class for `StyledAttribute`.

It hides the complex processing needed to retrieve colors and sizes from `StyledAttribute`. It also implements the `AutoCloseable` interface, automating the call to `recycle()` through the `use()` function.

```kotlin
@ColorInt fun getColor(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int): Int
@ColorInt fun getColor(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int): Int
```
Retrieves the available color in order from `StyledAttribute`, custom attribute (`attrId`: ID defined by `declare-styleable` in `attrs.xml`), theme color (`themeAttrId`: ID of the theme color used if the color for `attrId` is not defined), fallback theme color (`fallbackThemeAttrRes`: ID used if the theme color for `themeAttrId` is not defined), and default color (`def`: color used if none of the above can be obtained).

```kotlin
@ColorInt fun getColorWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int, alpha: Int): Int
@ColorInt fun getColorWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int, alpha: Float): Int
@ColorInt fun getColorWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int, alpha: Int): Int
@ColorInt fun getColorWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int, alpha: Float): Int
```
Retrieves a transparent color from `StyledAttribute`.

It retrieves the color in the same order as `getColor()`. If the color is obtained from `attrId`, that color is used. Otherwise, the `alpha` value provided as an argument is applied. The `alpha` argument can be specified as a `Float` value (0f..1f) or an `Int` value (0..0xFF).

```kotlin
fun getDrawable(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int): Drawable {
fun getDrawable(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int): Drawable {
fun getDrawable(@StyleableRes attrId: Int): Drawable?
```
Retrieves a `Drawable` from `StyledAttributes`.
The `getDrawable` methods with `themeAttrId(, fallbackThemeAttrRes), def` as arguments return the custom attribute if it is a `Drawable`, otherwise, it returns the color obtained by `getColor()` as a `ColorDrawable`. These methods are used for properties like `background` of a `View` that can accept either a color or a `Drawable`.

```kotlin
fun getDrawableWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int, alpha: Int): Drawable
fun getDrawableWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @AttrRes fallbackThemeAttrRes: Int, @ColorInt def: Int, alpha: Float): Drawable
fun getDrawableWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int, alpha: Int): Drawable
fun getDrawableWithAlphaOnFallback(@StyleableRes attrId: Int, @AttrRes themeAttrId: Int, @ColorInt def: Int, alpha: Float): Drawable
```
Same as `getDrawable()`, but applies an alpha value if the color is obtained from other than `attrId`.

```kotlin
fun getDimensionPixelSize(@StyleableRes attrId: Int, def: IDimension): Int
```

Retrieves size information in pixels from `StyledAttributes`.

The `def` argument for the default value uses the `IDimension` type.
Using the `IDimension` type makes it possible to clearly distinguish whether the value is in DP or pixels.
Usage is similar to `kotlin.time.Duration`, where attaching `.px` to an `Int` value treats it as pixels, and `.dp` treats it as DP.
`IDimension` also supports conversions between DP and pixels. For example, to treat 100 pixels as DP:
```kotlin
val dp = 100.px.dp(context)
```
#### Example usage

```kotlin
class MyCustomView @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0)
    : View(context, attrs, defStyleAttr) {
    companion object {
      val DEF_VIEW_HEIGHT = 36.dp
      val DEF_VIEW_WIDTH = 120.dp
    }
    @ColorInt val textColor:Int
    val backgroundDrawable:Drawable
    val height:Int
    val width:Int
    init {
        StyledAttrRetriever(context, attrs, R.styleable.MyCustomView, defStyleAttr, 0).use { sar ->
          textColor = sar.getColor(R.styleable.MyCustomView_textColor, com.google.android.material.R.attr.colorOnPrimary, 0xFF000000.toInt())
          backgroundDrawable = sar.getDrawable(R.styleable.MyCustomView_backgroundDrawable, com.google.android.material.R.attr.colorPrimary, 0xFFFFFFFF.toInt())
          height = sar.getDimensionPixelSize(R.styleable.MyCustomView_height, DEF_VIEW_HEIGHT)
          width = sar.getDimensionPixelSize(R.styleable.MyCustomView_width, DEF_VIEW_WIDTH)
        }
    }
}
```

## [WeakReferenceDelegate](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/WeakReferenceDelegate.kt)

A class for property delegation using `WeakReference`.




#### Example usage
```kotlin
class CameraManipulator {
    private var camera: Camera? by WeakReferenceDelegate()
    fun attachCamera(camera: Camera) {
        this.camera = camera    // Create a WeakReference to `camera` instance.
    }
    fun zoom() {
        this.camera?.zoom()     // Use the WeakReference as a nullable field.
    }
}
```
----
# gesture


## Utility Classes for Handling Touch Events and Gestures

### [UtGestureInterpreter](https://github.com/toyota-m2k/android-utilities/tree/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/UtGestureInterpreter.kt)

A class for interpreting touch events. 

This class comprehensively evaluates the complex low-level touch events of Android and categorizes them into the following events:
- Tap   --> `tapListener`
- Long Tap --> `longTapListener`
- Double Tap --> `doubleTapListener`
- Scroll --> `scrollListener`
- Vertical Flick --> `flickVerticalListener`
- Horizontal Flick --> `flickHorizontalListener`
- Pinch --> `scaleListener`

By registering listener handlers to this instance, you can receive and handle each event.

#### Example Usage
```kotlin
class MainActivity : AppCompatActivity() {
    // Create a UtGestureInterpreter
    // In this example:
    // - Scale events are not processed
    // - Double tap is not processed (--> the detection of single taps is slightly faster)
    private val gestureInterpreter: UtGestureInterpreter by lazy { UtGestureInterpreter(applicationContext, enableScaleEvent = false, rapidTap = true) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val contentView = findViewById<TextView>(R.id.content_view)
        gestureInterpreter.setup(this, contentView) {
            onTap { 
                edit()      // Start text editing mode on tap event
            }
            onLongTap { 
                showProperty()    // Show properties on long tap event
            }
            onFlickHorizontal { e->
                when (e.direction) {
                    Direction.Start -> previousPage()
                    Direction.End -> nextPage()
                }
            }
        }
    }
}
```

### [UtManipulationAgent](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/UtManipulationAgent.kt)

A class that enables view manipulation such as zooming, moving, and page switching.

For interpreting scroll and scale events, it uses [UtGestureInterpreter](#utgestureinterpreter). It is used in combination with the following [IUtManipulationTarget](#iutmanipulationtarget).

### [IUtManipulationTarget](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/IUtManipulationTarget.kt)

An interface representing information about views that support zooming, scrolling, and page turning through swipes.

It is used to supply view information and paging information to [UtGestureInterpreter](#utgestureinterpreter) and [UtManipulationAgent](#utmanipulationagent).

#### Example Usage
```kotlin
class MainActivity : AppCompatActivity(), IUtManipulationTarget {
    // Create a UtGestureInterpreter
    // In this example:
    // - Double tap is not processed (--> single tap detection is slightly faster)
    // - Scale events are handled by UtManipulationAgent
    private val gestureInterpreter: UtGestureInterpreter by lazy { UtGestureInterpreter(applicationContext, enableScaleEvent = true, rapidTap = true) }
    // Create a UtManipulationAgent
    // In this example, since MainActivity itself implements IUtManipulationTarget, pass `this` as an argument.
    private val manipulationAgent: UtManipulationAgent by lazy { UtManipulationAgent(this/*IUtManipulationTarget instance*/) }

    // region IUtManipulationTarget interface
    override val parentView: View get() = findViewById<FrameLayout>(R.id.parent_view)
    override val contentView: View get() = findViewById<TextView>(R.id.content_view)
    // Change page if overscrolled by 40% width
    override val overScrollX: Float = 0.4f
    // Do not overscroll vertically
    override val overScrollY: Float = 0f
    // Change page by horizontal overscroll
    override val pageOrientation: EnumSet<Orientation> = EnumSet.of(Orientation.Horizontal)
    override fun changePage(orientation: Orientation, dir: Direction): Boolean {
        // Execute page change
        // return true if moved --> Execute the subsequent page change animation. Reset scale/translation.
        //        false if not moved --> Snap back.
        return true
    }

    override fun hasNextPage(orientation: Orientation, dir: Direction): Boolean {
        // Is there a next/previous page?
        return true
    }
    // endregion

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val containerView = findViewById<FrameLayout>(R.id.parent_view)
        val targetView = findViewById<TextView>(R.id.content_view)
        gestureInterpreter.setup(this, containerView) {
            onTap {
                edit()      // Start text editing mode on tap event
            }
            onLongTap {
                showProperty()    // Show properties on long tap event
            }
            // Connect onScroll / onScale to manipulationAgent
            onScroll(manipulationAgent::onScroll)
            onScale(manipulationAgent::onScale)
        }
    }
}
```

### [UtSimpleManipulationTarget](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/UtSimpleManipulationTarget.kt)

An implementation class for `IUtManipulationTarget` for simple use cases (where the view to be zoomed does not change dynamically).

Using this class can simplify the implementation example of [IUtManipulationTarget](#iutmanipulationtarget) as shown below.

#### Example Usage
```kotlin
class MainActivity : AppCompatActivity() {
    // Create a UtGestureInterpreter
    // In this example:
    // - Double tap is not processed (--> single tap detection is slightly faster)
    // - Scale events are handled by UtManipulationAgent
    private val gestureInterpreter: UtGestureInterpreter by lazy { UtGestureInterpreter(applicationContext, enableScaleEvent = true, rapidTap = true) }

    // Implement IUtManipulationTarget using UtSimpleManipulationTarget
    private val manipulationTarget: IUtManipulationTarget by lazy {
        UtSimpleManipulationTarget(findViewById<FrameLayout>(R.id.parent_view), findViewById<TextView>(R.id.content_view), 0.4f, 0f, EnumSet.of(Orientation.Horizontal))
            .callbacks {
                changePage { orientation, dir ->
                    // change page
                    true
                }
                hasNextPage { orientation, dir ->
                    true
                }
            }
    }

    // Create a UtManipulationAgent
    // Construct UtManipulationAgent using the IUtManipulationTarget instance created by UtSimpleManipulationTarget
    private val manipulationAgent: UtManipulationAgent by lazy { UtManipulationAgent(manipulationTarget) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val containerView = findViewById<FrameLayout>(R.id.parent_view)
        val targetView = findViewById<TextView>(R.id.content_view)
        gestureInterpreter.setup(this, containerView) {
            onTap {
                edit()      // Start text editing mode on tap event
            }
            onLongTap {
                showProperty()    // Show properties on long tap event
            }
            // Connect onScroll / onScale to manipulationAgent
            onScroll(manipulationAgent::onScroll)
            onScale(manipulationAgent::onScale)
        }
    }
}
```

### [UtScaleGestureManager](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/UtScaleGestureManager.kt)

A class that supports zooming views with pinch gestures.

It combines `UtGestureInterpreter` and `UtManipulationAgent` into a simple boilerplate. The following example imagines a video player that supports zooming with pinch gestures. It toggles play/pause on tap and resets the zoom level on double tap.

#### Example Usage
```kotlin
gestureManager = UtScaleGestureManager(
    applicationContext, 
    enableDoubleTap = true, 
    SimpleManipulationTarget(findViewById(R.id.container), findViewById(R.id.player))
).setup(this) {
    onTap {
        // Toggle play/pause on tap
        togglePlay()
    }
    onDoubleTap {
        // Reset zoom on double tap
        gestureManager.agent.resetScrollAndScale()
    }
}
```

### [UtClickRepeater](https://github.com/toyota-m2k/android-utilities/blob/main/libUtils/src/main/java/io/github/toyota32k/utils/gesture/UtClickRepeater.kt)

A class that allows continuous `Click` events when holding down a button.

It uses `view.setOnTouchListener`, so it cannot coexist with implementations that use it for other purposes, such as `UtGestureInterpreter`.

#### Example Usage
```kotlin
val clickRepeater = UtClickRepeater()
clickRepeater.attachView(findById(R.id.button))
// ...
clickRepeater.dispose()
```

